<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8fdf68612860a84c6b4e3ce92d853ae82f5dc89bf70714c5a0123fbad56b7761ca84fc0f79333f793b4213447862b471677907bbd109d52f06994f4df8c2f4fcf9678f4a0b4b2ddfb3f5fdadb71ece4e3d56056318cdab8eb0b758a88f6f009c9eac65ec9839d93fa42b741fb4fc2cbac3e72de3e908dbf696bb66b43bcf45706aefffda6cff2901bacbf5f4d7dfb55e0c6064981edaad8a821258ac48ea857d59907123aba149b88946c702663d83a7d20afd0ac92a06d943e4f393e4bbc7f43a64401aac1268cdc9c46a0283cb74c44396b925ea2620528356f3d7a3c2c3ec2c1411ad5c713888939a9531a6e7e9a5598eb2381f0f0b73c384b4a32c7491a6c64dad91ea149d7ced78d67b3f2a1b56a54af889d46fc250e6f06ab58c12c18b3a07bcd73cc40e04a979fb5edc5896a347a7870899d0ac4e7b515efbe6c7f969525593efd1e7c7ad2e4999b75384ab548717c3db93bc8185d3f30bc08525f038bd1b04b4f504aefcd52c6f01fa36ef0659c9a2d12f389f640f3f4db900aa6ca5eced6f4894f6d99d8e891498edbbd7ab939128c428ee270bbe2cdd681f129ed616282139b30431c908f794a49418338d2793a8cbf1502f44c2939816a10eeabf33d864cfaaab5594c684ffed7c60525b59746c1304d4a7ebbda298f7d9e9398b1c5d00c292e5dd0ab142b16423ec7912d2d16ab290691ea4c7b240a7add3057079e5b28c266a24e75814020369a45eec9ce9f4afc1399191ad6f7e69935937c3f7319069f6efccb853d5c8b3f504a66f753d93a38c48e4ebe5bd16699931c9badfb0ceab94e9436b703f69f4f546b632d63206f6539ae4bdd037f49141bd57949c81029a5d1f734bf50f399033cc6875ef92ef23c5f0764a6b20a5d67b9f51017bbda177e34a165af504520c44c395c83429ab383bbc733b0cb57223531c19b6e8d576f94efa7f044de93face25396d2df66ce08005a239418d289378f6fadea94dd1b25023a2fe130308583fe823d6cf9460def661f018d2db9c26a9eccff43610b496a55d384ce204c2adf6f33256d4d63a0dc8ec130ec1f0ea4ed9b7281cd1a2d3eebd3d5b68661ab9dd17b0f1a06b22a4792f23704fc8a9e7104e9f558e005ff17c5e7653f47539d0182c710d36fdb6f53a184cde9b3e3c928079489e47b59604a380110907b6ec191f4fe8ab8618950e74dc91b62b5b144814296c4ba675deec4a22c64ade9eb4ad6f56c11194d27595601cf40a8fc5b7661a59e157f22404e75edc22365244c1d8408927f5d71ffc9d1ef1853b83ba45281ac8d70fab9e8a48e9afbb2999b05f22a07d89c46a4f491f426dcd28e2d03ee50a2833bea1e3dd54a227f9268db6d1d478af2bf24fd6f11dd4c2881a2d2741f5650b5251d4be54aa34557d14bc74bf72a9e8366e08c8c76d332ccace08b2163734a0a65cc77faabbbbda8029a4aa2027385bb2988017f2b4711f08428606213fd4b305cdfe2ea7cd04ee10d163b1f78de12f1a98939b9899712f2a9c458eee084d77ebb822f8be97d05bccc9c429f9283ddd03f6a5b0b0486f845f6c89bcce3d09a67c5df6422de481e58eb56cbaafc4258138723900925479db8cfda2da12ec5b427cc9c64a23afa22315c1e6b8acbaad0c31e4551505149c41f6b067781e578ce95a49d6b7ced7fe264c54c4bc6f1f87729856af5724486d11bcc7706eaf792796de1928aea33c93c7d0f6752ccb4b580332720fd49fa56e4cf7067a22b3135d1b852fb8dd912455b20c86bdbfd6dc47d7a71db13055f71f792899ea1498ef90a7e4eab86ceb0968e8f11d2fa2b438d5f1c8c582d1ace179bc38be7aedc54b22a364b80d77587a04f51cb0f36e3cbc6ae76b0216735eb179fb6a8c151d71f298ae1667b616ee4f5cb960a88bdd515d73ec8c4c797155db060cb1fa958f2202c924079e411fb2779ec6417e3edc4a97c485ab9a8aaa29d0de33780da0425eb2a4e6ae1e2d5a762c694cb6c4e4a091d01564ce05460038fa0c4eb72540360ba63145aab102f4a54ac5f1b5989ac9dc45a5eaf1b333878dfbd7f9e02f8516d6d4ff954d66c046be7e451e84c90635a33f001907810f4570a091dfe11853b37f7903830a85bea8ad1e1e3a30f9095d267c62a87836b207c15673f013366c3b5be6856d629a766278360979352b82e07abe4338b3d5391003ca935c8ca56f26640cba8aed55139bb7fdeea51b6ed47815758ade64ae4d3591e86d9c284eee6bad57b1b2b67b119b76b5676b76c8f445e1e06b78bcc2b497dda46362189fab89956aebd699058184a85092bff95e073ef0d0ccc5e8dc462bbcbc3e259a0669b2e572c9f69da13b3a7872c06c7b35c0741a49c618dc334a704732bd24a18690e4b289b5435ce1a1b15c4dc68c5b39ba1e5e2e2f6bdff0fd323735bf832f55c18ecc7d91705bd0c027c4b8e3a59cf8d05d004906fd1c6ab27231392a7e25dce00197d467163ea990b592b3789b151fa1ae8ae086d4abcc35c365dab5820384cb93eb06db489e576ef25a98112403a6796fdec3a1c7ed2f0dc7ab12d839b0054d2b9ed3cf1269c5c060132179131e321a6974434c1451b37b67ffd78cfa91ccbc2a592ac18434c7e22fbab7e20ca16fd173c7443fb90cb69e65e3b1deada6ac296d45c8616ac5defc936a2dd6db62ac6315a02a9db94ac30894adeb262576fd426d6b0ac5b70daf0ba68943c4b3bd7a68af9f496b0585eba268ef14f54d097124c56362a28d8f4ba5d953d9d8b36ec546b2bcb2e42af30febaf7317b5fb7c51cb98f693b9c0f1bc162bb3e7640b9d96a1053d63a6ef855c4451a372528533393588acbb6c67f7b1fef9d0c318c1e270723e29399d3b4c3589e7acac17e56dd72332d73a382e2dc4ec5d93ca528c389b5a1553bc2ed89df156b97b80261041d0c87b2a63c7ce9b6ae8bbcb632e08411e6132995637d1f2dca1a5a3bfbc661ea34ca68bc5d99fc4172ed17fc111375d44c76adbacfc593ffb1e1ca2cfb208f9ea704840b15678a3ee7b338012b58be6db83829fb15b0f78040c1cfa8294fdf7b370c7e804ac3e16a5249f8e39b5d8452bf0e0642a688f89acb70dc4d277022e610114029f3720710e60c28e0a3f39c3fc8f251ef42c7f6ed16d6431c143a03e4a661483ace212169e760ac65dfe5519743482dc5aa6bb2611919d13f6eabe3cda5e6622c51315ce4ff157709120bd98b56e6720f2b2cd7f4d29c6c081245280aecf2b85586841ad4f26af95b17ad76a2edb43ae62c67f8c4f94c21698d8e06cbddb927f369d7f348a2dcf68011a893d772b961a3a3e50f56e93927c7d1338b4578b9f55f1109f2f28197c0b9a2c7e7e4df17fc025f936661f2899acb524b00eb353a07d3368cd129e154ab4648584e4a7e769185a17ef0a5ae3f02259591f75ef5701762848e94e62c66c61cb209055506f0471212d38a61aacedbe28b694f52d2c9f8204189c8c200298ff65efd5faa61832e908d0c5c523f359f514218714f0dbd58c1522f3c6592d3a0de31149d1338adbd88ea38aea834fb5bbed8161b37db50f1380373f85a71bf6f216d027b09ee4b55e799cb2e56ed3dc79ab535db95dea948c50218af421fa8c7fb8a4eceab6a92bf5938e26224bda94fba4d8a22353d29232398897d56e8047726eaec7d6f1f496f4ab561606275688782dfd4480d9299c70945dc470c3b13c09b74d689f86cda37a527662587f909fde30abe893e1e07f4fcf3244cbbb458e5fb2d1355a9b5f8ff2db5063a084bfec6d92cf1a26a9d1c1da3426146bae87611df2b51bf88d22225b42e3e034e82c642524db8705bd727d8075f4f2466b8ab3eb2803190a83bd19340a4c410687160ac9e2806a64b8ffc101daed9a03dde0ea94eaca0ffda3f21f8843c6d080cbd2edbdf71ef7fb560c83adf355c285d8cf9f80be96a6490dec0b591db1b0b916feadf3db96231b10a8e3bb208d0755faf1eef2149d00d9779b40bb9293e1ebca17f251337b60ded758806fa46077f6c3fd880892e089eca6aaa959f79f690b24c22c138ce1d72099ccdf3aec868372a5880a7b9c274307e12e14ec57962688fb2beddd882e8a0640d5362790f83631a97d723964ad253bc9a3dd9f1d578df4af280e863bf40e7443adcd656a33b4f20c5801a355eb9c40d7a8a71239a682d41f228ea514919696f6772b86e7d998991331f304ae5bdd436c870dcd7473a81e2506a6e3b5e3b066e79940cd4a70aabf9f014530b1fbdf3ada3e5fa114e8b9820feb0f93b462784e540283021915967015797c91d9e2a0f32a6ec61c90a5e249e666b200618b00185776c73a77194d75457da1a5fd3f13a3a122d5d7e7de7194ab11f9fd499a3936170bfc0fed4f0a2e944cd6d07d1002a56234d8567da17ffe6d9031948a5d114844fce12562d6d7155eb66e6e98289f2f5fdf69952b5e1ec19216f031ab752167d50a3e3e9cecdbb128a4adb644380d02abe2f8f67c8840fa2b9e4cb3b3ae4e7cf5a0d9ea18895c1da4adcb5e65ecb03f16b58c8d8be1eb1ee3a70f322c19081a1aeefeb298fe3c3a1377a0d8b7d8656bfa24059ec011ac9fd57232e99537d4ca689579b8d20bae6ebc20da49fd93fdd33ebfa50d3aaeaf350f9dd8460a91dd2cb3b2634820dd75ec3d4f221985c10e48ad02072bb0f05dab950c93bbb43629b6f2af3cda2e323cfd7889c8042074bc34b30396b1752d689867902a5b37a5ddd7a43f4486ffddd87f6522792cb5ef606b0cec95fafcdaa4961e8c280411ae3aa1df84bb4eccc0678e9c635397f0465201f79d6e3ec69f75dc44c4e2dd1e98f8321cd60cf7795ee23d6e160ffcbacddf85d2edd371f6d2f0acb1b5ebd925f08ef97697a087b2c5393fcf0929c862ef1197e7643a2b03fa52c5b7f8d89461de1e1df79a2be7d5eb7136751c8c7909b12bfb75df8a8644a244332db8e0e5fd65af1a28e93f6ebe68e723cdc472da1518a5443a0e2d83ed0188f8586dbd4c000d2ae29401a487e9fe99e9d9d1f12de2421a8224d517f07474b0e5c6564755e1195fa9452b504126b4c98089422aa00d09f4bb729e5d13d30f7aaff3fce85a506527e52312236241d8044f144dd6397b6906f019d859681d80da2386619bdd4346fd6f1d7063c2012460415c5cfdc817f9efc7109a4253b306e4945e9bd8bed121fe96b4ed9979d5094cbc9e41b31171f233d89299afee780e58a8f04f0469897ddf4a33760cab4dffeb0450f74db226c8d792529fe9f923f0c5a56fcc6c5b7edfa251c418f459ac05b42a96e2907e54cbef3d409eda4cccc033de58fd9976f98fefaefc0f0919142be10e22f1d2b62d258fd553199b1682e45569fa62d6c224644dca799814951caeff47409ae7bae5e1be63760965aaae192b9deea2ef6df45d1ff249512dbd31e69f5d5f7fbc77c447cbef22f6236c6b380340d8059b40909849e3ee101218d8ca96870de37f5b30be6f8cfdc2ab40d3cf23d4448537af6b2a14ee35e6e68c622b2936326562349d2be9446daf227a4bb19060d6ecc2a047f99f636981b2048c093155b97f355a4e4fe843b9bf5912c38e146b5692fa8cf4ec3136305afa1b27abb0503fd0d444f028fc36694fa3828d56382bbce4948a84ac62644e5bd75a8f03de5de7497aadea58318b11052721cf082750bf9ceda5d482ba498d60c81b2cd8111b4347ec90bf66287e951262736da2967fa3063da8ea51abcbe9e3aafa8e5ed4652e06a4ab1752f7aadaa0cd680e3b2eaf1eb24a466fcb8dc183e6bc4e8f6772055fd7e99afb03a08d234d39b808df76dcb625abb6e1e71688d97c8836fd4e684466dd45d8010ef34d56a748b710000caf95338fbc4e4c6c8673c087cf8feb2da7a926fdeb7442461fb9397cbf9a4652846f635622d3c63ecff22cc4bc817ff44a7ca04b40db1391c42933cde17045b8efb9c37709cc4cf3e46b5a99c108b092bfed2eee3609d5cf824c974b735876dc0d6edade1661e0df50c0badefec9d8dbb3907848e7c564c5b1c04a2cb9c9109b158c5346f2220cac781d3e79bb9600b9bb11c6c58b4f8fac0d5030778807b9bf439aaf5a8e38ad783eac6b09ad71bf9ebed20a2efea8210ec7fac3c2240df9981dee13c5b4369de03d2b34b436dcb6149f87f98c463b7e7d831664801fed2f1de964f999b4f4c1963447a7ba7f20af969e983aa082a9c0c48a0ce739c039e7467443a785bc023e995506081315b530c424cc5d758d9ddd8eec67d745b8e2f78f041055cb0324f7eade45f13444e92781a56243e14c8d41915445265ff97e7f9243cff83ffe7f6cb216a3669210467c058d3f4fbc1a754671db13a9d67ba4dce658d6048eb5f2be3adf17307b6f94d310544f37353d21ecd5915de74c8e3cd2ef64f4c72903dda9e6f45de3a3961c758e3df54fa1e1e1a5c1a376a38ffac4b01efc49d72d6ed2ed354c4c35e9fef129edc2678e331d743d0ad3e87edbf6d042864b27461877be9e5eb9fd1699090a73d2a82d26f0bb0da9ec60c7613f2f73ab354f37088c722c43be61179f618e5f748f3e86fe9606cba24ee0e3fcef3263012cbaa02eb580fada7ef52e5b07012d151097ce61f16b391edc06595ab646185161b323d538f13333c750fb6d7330ea0d6f2a6e8604b664df0971ff1c0cc1d188575c3a6d31c9ccd456f128b55d1b04dc21f9178aac10639f8564320f2c41254eea18fbf4ecaa68d4722e635b68e1e9c886c152fdf58165112deec1608bbf83e06e04f204cb5649a60e769b530269b4dfde80bd10f8a7eb41322d09cba32fbd0f96cb0d6e82651afd27147fd357ecb608949d58f79539b887cdeeb46d8d0e483d11e0e6624873a021d5551f1561f2142d4199b4e58e1a510cc636780448422ff226e282ea0e60ea74035c246a71937ca956e8b89d03d0f4324564434907f74b26a9b3b5c55ed9e7dcdcab3fd2d5baa66e372da4f10559582ed110dda66f93f55ce4673cf31ae78fb6b7ed84e13dda77e10d9ab8f0a42cddd9408c2c327b931c11cb18a1c304b5eb34e8d5707cde997ee13800c411d90dae043fd4a71171004f7520b86d1446ad0abe6e9b2600ca90c857dbf4a0846ac42c8eb489cc157ce25d32e315f51845d19cccb9657824eaaa395401e44c774ef1e7c81ca0e1ca995dc38201afedfd00bb8def677b56765db6dd39d368863dbfe2c59ad5ed2d9ce39bdfad50a383346a31aa1fe2d25916b3bdc111fee124c2ca5ebac6fb1e97f53f4891380cc0192da90c82603cc99fc83373145be2c47e68f32b32947caaa87acf1f1da6916850aa9cc917e470596d88e73d426434c87c4c046dcd4cb2aa8233ed92da4e79b11e2b4fdcbe9e6dda9ade10d87f65ad7f99b981c0bd4a055336c63d55ac2cda15632a1d2e6dbee66a74805d3f5f88f16cbb12459f9a76113d6041703790a3d5ba9d5a0e992f619552421630a0093e14bf15e8b9bb38bf0f2901a90ca2c14a686969fc773ece177d48aa45da614a9c950cdc96b073b112d463c8976309288c08fc30bd62e6d331ab1479f57788c59a5e0c0e7b5f33e40a63714a1969f7e879fa955d5b433ad51b925fe0c7b927c2692760b9e229a4e1b8f1d18e27e99a8a7fc2bfbc9748c0874a04a152cf92a9defd87ba28bddf106b4309255b1a32ce099d4353bfcf6762ce180244a35d8e0c18503caaac7d081bec58352b8c7b496d7ccb26bc1ffff134baba152d39bb49e20acbc9ab104242f71b621279d39ec9eff90f701e7b9ebec365789d7c3a6312390328cead4d6601c3516652922388d181074ef3d34086d658d1fddaf72cab974bb9fbd3b5b795d460f86c280395daf0a448c357120476e3225382593534326eef0ee70dc151e7ceee7a946b4fde31432e91e6b336881d8a5773093e64b7208837bc8ebc5ccc0eafa85b5867a6eae174fb85536d5a78005566afd30044319a41a33e373e754dd8a0d892d11f4a2f33b63f73d978254501eed45cd5ef48613eabdcecd3a73df0f209d4e918944adb4141d0b6fbe5a719104c4374fcc288db92e0e48f5afaaab8446867fb79c0e53154b4f6329abbdea69c795cddf3f764a1a3d640b019e95f3c6a797ab95bbf7eaa500a2c9d49af1947ce99f0d5a9cf7e33f05f2255440eed36c3178109909395565c65772904d3c81d8c3043be1d3e13514be4c1c328729a8a57661452198834afcf4294dbf30a0ef0682ed6909d9409c99014c8f3b8bfe72937ef1058c877710f5cbe137ff5da3e22bc396c04eb8bfa186a0f4a5ddb8f410e95faea7fd1cdb29a8eec73365e73353bfa3a0363075884f3992b180021f427e0571815d76255b5d7f1602c1f6397c71a21e3ee256bd4514d4aab32a4a7d0b4d500","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"752ab6882e2fea4e68f943960938f2ac"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
