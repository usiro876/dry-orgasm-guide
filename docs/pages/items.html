<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c61fb51209957f6e6fbc95599bc1988f1cbc30b7bc7f1203a7cf22c03e2ede3d3a44fcba0d91877447cd46a44c9985b2358d5cfcbaa7ab0d6a9b3371b49218f23065f1f760a9242c6067e82a92488c21cd3dfe04d67571c4d9f1399f802ab62015ea8914cd7ebe563845334bb7c6700d6a9b13bf22bedb73cada3724a2e66b248d1768e25044b78b96de13fd98fa118a845d6f1a64acb0687a037ca6cfd7827a7b575a88f15e2e578fb4584da44474063d62ac815075278a78be596d4cfc6536767985939522c486814edfc7f04829b9dc10f1caf2ec1f486c44b986b25500f248e4c79b70de440ea4dea18a2edc3b871bb5082082cf057cf23e8e0893315acc9140dad5cc8bfb8f539ebc0345dbc9342cad1158ccb7a7b978acb8dfa522c6c1dd95e2bf909b21ddf2a6aeb5ddee87039bf0bc3598a066a4852c863ef1ef02058bc97546f210147da9bc6649ff5773e6855c43648624b4a7d2c297cc5f55a414f30f5c0753482697581cc24502a293897e4e91bd34ec9f00abdcf1ad55021955e45da206afb453c2e7ec4b8ad297413415561ee50a442b927de113729b328b6297711568df625412e3f3a0ee1039de9e98a05ad4d187d8eebc8ba4e99005b3dad114cb6df2aadba4afd72ebacde617fb8da1c6d636ecc8037fd575bb2ee2cb5ae1f0ae4aefc06f75ab900d98059ab70bc9b9d3de5ed2c99536f7c7c2215eb4e7776ad439659de011d909cefca8d2c6b538bb099114d690f897ccab308f87959d3a0aac84cedd3ce2771b9b36d82a1c04ce9ad63d2b7b0125e33abd9dd0a450c407e9c0e582eaa8f4c085ec81a859dc7713056da7db81b175ad30117ecfb19d2910d5d099f3e88d6bdd9563a1174a21f698b109ab6500f19e4bdf80b22132a7ceeb10c7aa11c9dc9568111b0dbb7f66bda289df09768f76d51634020af08b33ed7ab1f91152a3be752382ffdc2db8b300f92a566d8959f9e73ce20c051960b658a91c62d4da6921d1aea675cd3af767db263bc42558a5b10337f36704bef1cd6b2dd098f34de22ede13490321f834c2f112f5edec307d4611d22d0ff488bb8ffd34827f89328c15563fcb23ed04aa9683049f2e9f01f229177fc766aea33813dabeef3ccb94b3fef75700500850e7c0ffc2220d87436f754e50dc5b6551be79538a5ed366b232e604e7c8b8b38332bf48cd00fa972752f30f89c45835487c1b456348ea71281d569ee4968505add90991aed064ab90f078deab02d992c3bad3d866118dbeeac91ea05854a84c7931fc41de92ee9209507160856bcf5fc5b3f9c2caffa4b51607e95ab29e9c385f920dfaf718d9e33e57c6613355617b084822712e73515717492c700d17a632b5823c3cd1b215d47fd1ad26ad22dace44e85b4b7937d8702212083d3943eca56c698f8db97e418dc5cc23b16664c539fa528fa34a8b7c8cc8e5484200af48066028b717a61c28ae68862d412ebc2adae470b083ec686a3584f32ecbad19028b7db0b0802fa19a7eb707a8ef6430088099f6f92b231645890e2e4858890512492029ad00f6e311a442d41bd07837f35eef3afbb2dc3c0612f7eeaee63da9489cfa5801fa7bbaaaa24f6818c861914f9117263f332205a2d759b59a7da1964cecd5acbcd16b502ade936477ddd15fe78ac756355efd1bc1ed4cb5e05f33e68e6c5811f12d9643e2e6112ae331e2fcc29f14136c609cc45a9b06e56b7f903711a8713b6cc82c645cc0063dbe2b645c21d3db8d8971d3769cfc245ea6eb413e896a747bd5a29cacefe544b3800dc009350defdac8ea7d7a472a0df8a79dc8ffe13f6bb60880133c4a0bdc76182dc95fb0afba830a4051f8a2d72ee68adcf8678bb1b57bacaa5de7e7bdcb2f0144bd102dfa75a0e421fd7acd871e3ba90fba7d86c1bb8ddd87887814f452311ae7f2f1fee7c9bbb9299313055f20e5205a5fb9a6d5d715a7aa9ad79db4ebc9bbc03155624b31604cac3b30bd738ebd993248c76f08f858c11e595a6be7e2f094cdecdf8d4729a7f6de9049e60339023d8da2957a9e4466d4300b433469d46e84701ce9712596713bdf29231e1d27181a0949eaf29b6516f4c70d994e07482563535ca0baccabc34f8bf8214e4ded77617f4de98f5fe073eceda442130213f6ffd325f8c6f56e74fd7fe8ec83e431180150e96bee80be089b451ad4f1a4ebd414503a38427942fea1c61343afa69e3c82d6e83e7b5844e2a2679b911985bbcb89a378a6c18f4ea4246ecfb009791fef8041daca7a7f34a8ab525eff6e5c72793edc292849a6bce6e13649b02c68d66c768654e5edca184fc69e18ca3b0ff53d9ee74625697ed43cc8c62e19ef54f1efa462c3c4fcb967d70e99e6e1c23b7d43546ee34ede4f4f483982d7b059424ba74651f58ac6ff16eb99b9b4bec693e1538dc1ff8573e081566fa7d5a702397ad9ad33b7a2473a4f7654cf95e7f05926e27bff4591689afd76f373513fb115aa1961a58ebfc57564351e1d2e89441711bd751db70b10181b3d5aa94339448a9de0c0d34dd1a624871c1241e20fe8780801239d4abde969609f076312abd611cd78db27cade176c464f56ae520e13a389fe53d8eb67b8813b70097c79c4f3ade72501ebb3c3d30cba8b953b0735151a7e207bd9cdfcc3990147e5f27b1731e6470cf9ebe62694d4c78f81365b1e27c3e5208d33c0ec998e9b4872072a50eba7c9f81b971aa4df932817b8ce4a945a7d5e16046ca268d8a431a4e6608a5009abf273482cb6a8f7aa662083cb8c5316d47a7d654ef32176f118b7603228e60c0ec807003f3f143cb1f51090ed37f581c91c3a3d615f7572ae67310fb3cb5abae2896ab80066bf916b6413c4074437a1852928ef9e91deadd94657dd2483631ae27678878246bbd2b14fc297c03d2408ea319e9b8b7747253361ef413aee36189b7fc85704fd60705943f77a32e72372b59a77af279dedb1f45b071331ae1b50aa310a037fe0308f6330a5b6e4aa8496712c7c5d33b2f62556c9bef30280509cb5804105ac1eeb49d91ef0b9452230084a68ad80329bf6a4e9e50a1a716b1c18cb8d6edc676d5b82c41e12f104e4e0340dea2046334371f9d553599a4cdffb5de9a9a8b23bba9cbc3d12b5d4ff20850da6402403a6fe0ebd17932cc2c3ed3e014952180ada1bdfad982a876d8723cdab526a91775e5c1ab641b7d8e53fadae602e54c9fd6e4e30a45496262d7c54511e8fae450e9faa26b3273287b0e4228fb1c6428edcf4f18255a309c921707ec8f855e69d0bf8a33b5f963906b69372126ee0c3fc8c50ef1a855358bd268bded0559eb129a213ea0650b35ac7b0794b1149e39080d49df11ad5c4e6d63facc25421f3db3fca5779865a17fa8e3faacfabfcbbc2f4e066bab8392a2815325d2c698d27ef22476c77774d835d72541867f599903b03f9260979d111e56fc82624e04e5394dcb6fcbc68cd624132f4088cef03cdf23658326036c1e53e75c01ce40e8633a01cd9e6cf89abe8b857c2025f6cfea4ceff36a1a5c49cf54eb057c1b169a2218a4c4e0661edc712a944a288edad75cab930c495784ade5bb59c1db6ba8407b83e0db533812651f32ed8f93fb4423951390796833d9744a8969cca4dbc921015c3cfce9c3be83c9b62b855418fa852883251acc056983c5b35ba4cf3bb9353d5ef439255f55f65700be6c4af2f0b08846a936cf397fc3fa0b3053431f59ec72b825e05b490212056f5847fe002126dfc28e15c119f4454cbadee597ac4737fdbffefcf8d0263b9c8eb76131fdc2b93c95e14765fc1fbbb482398f05a70756ac4fd112cb17bb5c5d4eacb4dddd9baa38ff1453e1fd97043bce1010b36ca318c16e84f7e3fecd1c01788014621e78e114e586507d3c41d8f7dfe2113af716f1453ca8510a850c7e49ca1356cfb757ae0e706cce71ecb438651e6cc32e63e59f2b423d109913840b94b306f5f74b98c62a5ebbe6a9ccda007182d4f8eb86604266aa53670c48468df44368540931ec008914d8995f7dc3e27ee4f9124255c3f7514a064bdf3a4b06213eb8d4ca387a7a70318efa8e0e517dd49eba880fbbff37efc2b82d27c692e4d7a4beddbcd8d46817f09c47402efdd39b30bf214cb3c1b179e150f494c983f6f20fad0339e6a5faf6ab4251ab0f1163ce406041201bd99fa19d5f08d10d6444a6e0880ed3b755b70fb8a8a0c36e22f9bc4ca878720f576b7e34645e00ba470309208c0837daeb1b84a22ddb61107081cbd949778eaf2774b185cec4c45c6bd5c91b3b6317e41af52b2cdd0df1820bc61d2924d9cd3f1d8c25d610d36570d2ad1f98cbb64bd886b1bffe5211bce934416b12f8384c3a6e344af58939aaa997727acea71572dd838a88603874ed7cc176a007d3a7edda03d6b00f633cf737ff79aa40d858bdfbac0c0f67028efdcb674be14a9f347dd4bdb668ce601b3ee6ac23cbb6a05ee5d53b959ba72c7d5000f887a628d6532bb289a73e84e2ea61f51289ba8f5886109be1b6a88afceb7dd39ef2fd627e805084b3c1b713aef78c6372aacc27baf35576d89c6608d10d57eace42fcaf224e238678c329a8a1bc222152382f496c42ab83290e3088d5ea5af222e81c2ad563ee751cc9382dd45dbc2208b1dd2a4f3ecdddb48c00e3dcbf4a307f979a7a02955b5ee2504c3c9e78d82c8049a679b27eec6ae9d586c7534b5bbe3ee78531144067e6799f528acc0963c124c1e9a025d0376208f5d0ef81751b47b84ab3f354d521b6f455c6c9e73b5c3089713b21dcf5d0540c4397efcfed6bf2c5365440492b21406a8032239fc8d1605748813a3ab0392eb0d6b00c084aea098c9d9deb64d5e2b6c0eabee20718b9c9c33760f8d49fd70236de1b9fcab78684fc3d2eae590d465f16798fa19d1b1ae7e79912c45d9dd5efeff7713c47e63bff14cb3157634405c08ad510582c3743e2bbef54e02e863415b46f5e2f1e66a6df977d6eb2e01d7a9a68c2b13867f44860faf2f949f7f8a29e569f5dea61dacbb8d828940b7f92e869cb4b0a0cde8157c14f6e1121e04dde3b9724eaa775750ff97cbf6b9da5e10cae52a09ee49daf9c08a9bcf3692f7014c004890b4dc9520f7efda9bc21f809a34b02ca089bc05d580c09326b935ad19667e49b084b08bb99f53772efe52ac324606dd2e7a54f1cdd42fa0b13557fcd692b1352112ba18ae0a1bacec4a59a37feed2c478cc51ed6a6691fc48c78dd00e18f5fa564a51177fdc221d04a24b1fc1f963690311628e766351e5bbe27ab2cc9ba38699d998b19ee5e63dd5432f9515f9a80b036983e5cda5954df7fe3a743fe1d4a415f2cd486a37ea9f999fee42e76a4394f1966264924276d7852355ac1a640cc636bb9ec92fa506b9bbb6e690f65f6bd4b9dddc289087474feee0160322afb1c11d6d0663e0bec46840ab0a3ec40cca837b9d82d1908c396b4f0a60565b60efdce539824351ea8f141f0df80c0d9f3926b8520f5d78ff07f6adca76eb64fbe66a096d2d8b0ffc7429e50a12fc3b73c58c438718b4a1b6f8471b6f35ecefb9189f70513562a0447a280706a6bc4c12eebc0552be339610ae52b1560950c72640d29eb0a2879c68b91e57bd2ee41b9f66bc4a2b965585d052318e42a35ce5b6a6a8ebf5e16520e031bf0fc75c5b5ede8c9384564a822989ede6a864e4f6db7c86bb26e4d5acd3ac29c64f280fda7c0c38ceecb0f89eb87f50cc9a7c9def8f4209771503e345e412ba25806ccef8c13628a204e50b8ec36ef3d07c209c97792646ddcd727bee68c8adc5ac8a7d3c7a26a9ff70dbdbd3a9e440e7607135e992fe81b792a0c2536d6e75f0910ee21b0283e801c6392e83e6aeeb4a25767c00941747210deb01d685111a351710c23125ef662957019f6fd36c4d83a3733dd7bf596c49cfa89dda19a6ee0aa84ccf458284c9420d8fbdee3c48028ef5ec85625d8af667c450d241f3b2c5f4b97049a29a14fe573f1cc106bd9b9cdcacb26b65ca0f65192842e5c5b791de096259c325cec276d575ab1018c8141e4947a8558090dae3c1e3068f56e43b419a3f5d596016dfecb483f895d25a27c185f36229061b0b5e71da6b7c5b9f5f3e5afe90c3f4350d4264e301756e0405ad9c2799682c25d6418873a3e61011df057c753a48d3e7875a4aad059457e8602417f1f7ff24ded5366cf81c24036cd78afadfaea77667bf60732075ec405de1bb0296312c9292c509615f79a24019c6bc527cdead1112e816c030704bc92fcf31f350c17f9554d4993bb55bcd75bc05482f69fe31a0683f4629120c3f77d559e5ebb34c214e55a09c5a8a1e063d558244ed04c9e5c6919b1b68f5d679ebd514f4e287d3c4a3137a6d1505e019e26d097ae0b09476268faa6835d309205a4cb5d1254d0024b5a642cc0f20d572ea41202b222865a260a518f927530a8298e803d905182ee945fd9236e2aa8d199b4c52254889199a595f36747c10a2d160fee360f8641cd2fc5d818ba6bac2d90b907adb651412550ae8717a9c0f678624f85fce4de42a093b34406f0c03725a6876a69ab8ec4ce9e57124c3e58896565fa574fe3676bc96bfaa8e7915e76ca5209b86e6ee7c1b48c896457a888ae9a63577813be8bf1a002bc8f1d09b0c0b8aa78bd76f504802c4349f0edb6306377bc6824efe991a87956aeca652716026def7cb2d150456faa6674c65b3a52e58d4d23b7085a47e6906824660639dde74f5e136c66391f2ae39d62ab3b15c20884e4cf4ede08a4e0e4cedbe558f6972b4fdfa8d1a5f45ee9892414335d21bbac875ca3219a528494f4994383d40672e29a82e355208824f33950ff48059e8d282e7575d4c896b8527071084dcf43eab6a32d726ab48770f4d23dc1dfd04b7a7d650110b3678c7ba7bc547f62f6efb226d66d47970bf86ebad49dcac4373487efc2d9ef9ff2b9ce7c78807e820ab405b18ff67ad430b826447e8d0137ad887cce711a15054012d5f5872196ce35b5f17e4da3c26b99a29d68dc60b7f211db2267d0616abbf958c2c16342b6b90c13ee41df02934155b2487e9a8bf678383c92a2787d1440c456d3cfca72a082765dfc3b027cc10f1f9ac4f78efb0fbc1cc6fa9dc81aa9f64f89b2ac853695acd331fa52d039761a0a386e09ef33a9dd62f230c6f209d9de948ae80c89c2b6f4da70c75e18954134ceb5943b5b35b7448e8cb4ad578bda7e17355da3b6d9cc0a9b297822dccd013a4177bf1fe2520ebf41e53efdb7d4e72b9b75e05ed59ad084eb0bf6d5c36a52ff729cbc7a393085a8a99297fb5bdc80dbc9720a8f2b445f546579bb7508f389dca9b825046d7d6511e5a8daf216f3364a2ee3edc71c24490d6b3235e9bc743cbc8c62201cea78b38da8020fc3787ed70ed542f41fdd3f03d311949cb5febbb6a4c80c101c0fc974dcc37fba4146984a71a9ebf60e3e13d242df1effb36a1680c95eeedf52ff47da8d7543550c2ac7cd6caafb4776582cdf08dede1e9bc95c37759391767a0ad9528a5daf18664cbe48739985018fb48e6c08b3c8891bf28bc3839ddd7a9f58b6f5f9e7571752c660ab66e18304c702090ea5c51a5ab1db8cdf15a4cc6d6aa27a8dc61829aaf48191d3a79e796eb3c8c3c99b7b095e045e6a0719e57ed5566b788c26dd199d8a9e9910a4ac8ec67c3b384684b212a8186cb257746a4509724586ad5f142bb398566d32db4fa9ff6c2a128c124057305556cc183da75a6220fc6c639337abfd40ad15dcb795658f5b474fa5c71848dc135acc8cf9c8c3b6601d1569481233a27f7e7cdb1e4c723ad449b4588c49f6187948520bc798e125784327ad983f03043eee34f6931bba3aeec86126c6c592f28791a6c3d56c0c8fc4a4cd5d1e6d11e2a5e96c019d9ac15838185dea2ff2981d271ced5fee5e49f0c5266bb96052246fa8ed46047c08aceda93c30632997af19bdae53e72eecf672d7846bdb756fc5b40cc42c2f87c7f54b8b1e6179a517bc2d29c4e9aca6f5e464e78adb748b12b24a06ab56dd68388684ab1239ce929289efe1b2dc58e7a16f87a23396347945471cd11f983cbcf74af4da5d8e69471e87f17e6ba88454ffc364ecfcfbf1386efc8f3ef32e49795e1f062b2c4e9f62dbccebc74c3b3da30dba409ca3db424c83ae334362973d06fb8bbd148c0e90676bb320956dc56c6084ce8979b9e8cb4a8c931351057e17872f3f6ad88154c603de3ef01f1b19fec4897f7928a872047dace4ec439b3fd81a886ad208dbc5e48470b1b42ea15cffe466bf19a4f41fb7c6d335e365e58d98aa7d44ce2af2de55501dc3e1f98f98ca9f1cd0120a36baeb41be48e6045a14391afb28b61b51105bf4693d1914c1476ef76c3a5623618dc288882bcbcb1a52e2bb5cb778e25149aeeea3b982a3fb6a906e9d40dd6f3dd0871acdb0fd6ac52f6ebbff67f577399d71f42919194f4d8f9620872cb794d6b34fe00827fe866c6b045fc210c3d9a54f73f8d10a6c89ef19e39fb22b60b57d53f5252c8d5f167fed7163b3719b9077f6f7b124a3873a68f0d0beb8c5743a5a06e729f8adc5ef8b1beec82d953d1a0dbec0873f3b365438152c4988f2f42f64d39c0f1055a7e52cf82465f3ac1a7634f4f25f6f14ce6ba7815d93d6e7e23e6a77756233ae3b22180792e33a976104ff0a95e256b2f5f3fe221a43a7b655cfc54ac0c9aae38c0ea89b744d4f1c11c1379df8c50aab922c9c03e7cb4edc27627d063cd77707bd60bbf041f9dc43aa1b8dbb37945d68d058edbaa53f6a96b2dd2685c9d0504883c7f00043be10a099b41ce7f798034f46b9cd4044a6fd36d09f0fc7f74a95d1a743425d8912ca59fd5687644a57184b832ea48cab90656fa28a9a23d9b66e2ffc1ab9fbef72f670179a23768899bc74c878042f5721f64fe4f92538fc5ff4d4ffbfc1a94c28f79daa0543e7d0a59c1552c90d56022af2de93b390ab428f9c73c88b2540d8263ab523149c0d981bb0df9baad02ffa16bf869ea78edf94fb5dd7a5b812fea0609c2ddecae9b0cdaeae914d0e2c7395ca9cc0d41fa16255930cc274772b830371a041ababf8420715d0ac1d9f0f13e80e6fc62e8b6aa3aa868f39ec53701843e0617c90063a619d2fb5367e87c499a2a1daf4eb71ec8792cc738b293e2764b3122f0e7ba737c81458773e9a79e6ff1960a1c745bc5b7c492f49a2315be66392ecff2cfcea58c58dc8736f2022e460abee1003a58c4fc22388662bd711c9d3338ebff58329ba389b27a91068be28c7a04336347b80f737216f88837cad0c0e2ae2d9b6ae84262cb69201bbab5ec5d43708f864e65a00cc176391a6259e8d547c0ee3c60f894ae97fc9266bdc91e5b7bca49608af4bbee8c341624dc013e0cf0b5e980326893cc5ca9e477e72bb88505683626152ae690fb593006d496fd80b28d1bcc85d470d54017e5769768ba6b9cd8f63d166ad7e1ddfd7a5ae92789bc6403bb771ee0e8012f7b710ef28adcca484097ceffdd24e5ee6efe015828e84182e80e4d4590c7ab42ab11eb935dce37735768283938736e291f30297e10828b2b04393ad0850119758fb929f4f9b508b8a09328cc971ece186caa5ee4d1c444c78869c11c63e2cedbea13e4f91f55427fc4a6475c4a7e29c424d493a4ab132c39824d657ddbe7632a25bad865a20b4dd43dcedd034db3d0969478f15769a82ae1c4a95b0ee6e122b09422f43c036f906769dd6f6c67c6412294c3df080f3ac43a06e1006ff242b7700a6446e989b956bed428d8d9210301394ddb0bebe4715c8a6a045e28ba739575f619395fc53b54b3ceb44397828baf663b5a811fc8f73e31417386207e8c8967e5c1f11eb026f81c6d76dcc29aac7ccd16c8b4fd8b2d29f40c549ba0d5f0a352eef3d47a31058514428ebd80decacb8c7c87509561a2d9a6ca25d9adbf235ee167806244b4ac5807f2e6caf3bd81c63e5b714687133ceb28a75a52df5339d652556883d2cac109dcca4f2d024554e643338023f393fa635028ae5f45d5e1d052c81685ef35cf8b1b456651ba268d9abd51f543276a31ee34a9f56a5db893fd093db946302d9e84b24f357659170e2869c14a06edab09e6aa3c1763894676b8159872bf7d3b4da271647b07ee8dd1e5a2be71ef55bbb3663fda0f9820c1bf9100ecc721787cec04403d6b7d5121e85fc24d7c84b5b6685e47e42b3e3a4eb2c43c02c6dbab46b408ce94b8f85978953a225e24c21cf5d860ed60cc03066b6a2bd1fa3ed2a346f86c41e51c1e4edc1c53da42e78b444dc7c1346aaf4643a574f36cdd0497295431a5a60a81fa1caa34de170e30a7ed9239158ab6f26bfe88c88ec07e79a22a2388ceff5037c437e0e2e0227d44246127da2055e8f1ec6f300b122851f4204dba903cde5350ef0026951f9e860926b26cfb105e16775f3f033b1ed780bc","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"752ab6882e2fea4e68f943960938f2ac"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
